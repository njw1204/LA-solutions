# 14595번 : 동방 프로젝트 (Large)
* [문제](https://www.acmicpc.net/problem/14595)<br>
* [예시 코드](https://github.com/njw1204/LA-solutions/blob/master/(BOJ%2014595)%20동방%20프로젝트%20(Large)/14595.cpp)<br>

<br>

쉬운 방법으로는 시뮬레이션이 있습니다. x, y가 들어올때마다 x와 y 사이의 모든 벽에 부쉈다는 플래그를 세팅하고, 모든 행동이 끝나고 남아있는 벽의 수를 세면 되는데요. 이렇게 하면 O(NM)의 시간복잡도가 됩니다. [Small](https://www.acmicpc.net/problem/14594) 문제는 풀 수 있지만 Large에서는 어림도 없습니다.

<br>

잘 생각해보면 x와 y 사이를 연속적으로 모두 부수기 때문에, 모든 벽에 부쉈다는 플래그를 세팅할 필요 없이 양 끝에만 처리를 하면 됩니다. x에 부수기 시작했다는 플래그를 설정하고 (+1), y에 종료 플래그를 설정 (-1) 하면 됩니다. 같은 벽을 여러 번 부술수도 있기 때문에 플래그를 대입(=) 이 아닌 증감(+=) 으로 세팅하면 됩니다.

<br>

이때 어떤 벽 x가 부숴졌는지 확인하려면, sum(flag[1] ~ flag[x]) 값을 구해서 양수면 부숴진 것이고 0이면 남아있는 것입니다. 문제에서 요구한 남아있는 동방의 개수는 N - (부숴진 벽의 수) 입니다. 시간복잡도는 O(N+M)으로 여유롭게 통과됩니다.